
bool LibapxIsFixed(string s)
{
	int x = 1;
	string c1 = "";
	while( x != (StringLength(s)+1) )
	{
		c1 = StringSub(s, x, x);
		if( !(c1 == "0" || c1 == "1" || c1 == "2" || c1 == "3" || c1 == "4" || c1 == "5" || c1 == "6" || c1 == "7" || c1 == "8" || c1 == "9" || c1 == ".") ) {
			return false;
		}
		x += 1;
	}
	return true;
}


//Function to blacklist a set of strings
//========================================
//ex Replace unit Interceptor Carrier
bool LibapxBlacklistparms(int catalog, string source, string replace, int p) {
	bool stringOkay = true;
	int test;
	if (catalog == c_gameCatalogUnit) {
		//D8Charge D8ClusterBomb deleted
		if (source == "Interceptor" && replace == "Carrier") {
			//I'll need to make an array with all of the interceptor names and all of the carrier names. I could od a string contains but that would result in over-blockage on some things that are probably not useful, but who knows am i rite
			//For now, the base carrier interceptor crash is done for.
			stringOkay = false;
		}
		//Replace unit BroodlingEscort BroodLord
		else if (source == "BroodlingEscort" && replace == "BroodLord") {
			stringOkay = false;
		}

	}
	test = StringFind(source, "d8", c_stringNoCase);
	if (test != -1) {
		stringOkay = false;
	}


	if (stringOkay) {
		return false;
	} else {
		LibapxPrintOutput(p, "Replacing "+source+" with "+replace+" is a viable way to crash a game. Command halted");
		return true;
	}

}
// y=a(x-h)^2+k
// solving for a
//
fixed LibapxUtilParabolaCalc(point vertex, point pointGiven, fixed targetX) {
	fixed xh;
	fixed yk;
	fixed a;
	fixed y;
	xh = PointGetX(pointGiven)-PointGetX(vertex);
	xh = AbsF(xh*xh);
	// y=a(xh)+k
	// y-k=a(xh)
	yk = PointGetY(pointGiven)-PointGetY(vertex);
	//yk=a(xh)
	//yk/xh=a
	a = yk/xh;	
	//y=a(x-h)^2+k
	//using targetX
	//
	xh = targetX - PointGetX(vertex);
	xh = AbsF(xh*xh);
	y = (a*xh)+PointGetY(vertex);
	return y;
};
fixed util_255To_100(fixed num) {
	num = (100*num)/255;
	if(num <= 0) {
		return 0.0;
	}
	return num;
}

color utilHsbToRgb(fixed h, fixed s, fixed b) {
	fixed rgbR;
	fixed rgbG;
	fixed rgbB;
	fixed t1;
	fixed t2;
	fixed t3;
	fixed v;
	h = Round(h);
	s = Round(s * 255 / 100);
	v = Round(b * 255 / 100);
	if (s == 0) {
		rgbB = v;
		rgbG = rgbB;
		rgbR = rgbG;

	} 
	else {
		t1 = v;
		t2 = (255 - s) * v / 255;
		t3 = (t1 - t2) * (h % 60) / 60;
		if (h == 360){ h = 0;};
		if (h < 60) {
			rgbR = t1;
			rgbB = t2;
			rgbG = t2 + t3;
		} else if (h < 120) {
			rgbG = t1;
			rgbB = t2;
			rgbR = t1 - t3;
		} else if (h < 180) {
			rgbG = t1;
			rgbR = t2;
			rgbB = t2 + t3;
		} else if (h < 240) {
			rgbB = t1;
			rgbR = t2;
			rgbG = t1 - t3;
		} else if (h < 300) {
			rgbB = t1;
			rgbG = t2;
			rgbR = t2 + t3;
		} else if (h < 360) {
			rgbR = t1;
			rgbG = t2;
			rgbB = t1 - t3;
		} else {
			rgbR = 0;
			rgbG = 0;
			rgbB = 0;
		}
	}
	return Color(
		util_255To_100(rgbR),
		util_255To_100(rgbG),
		util_255To_100(rgbB)
		);
	
}