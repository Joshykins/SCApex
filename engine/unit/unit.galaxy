//=========================================================
//		Apex Roleplaying Engine
//		Copyright (c) 2022, Apex Group
//=========================================================
// This software is distributed under the MIT License:
// <http://opensource.org/licenses/MIT>
//=========================================================



static const string UnitNameDataTableIdentifier = ".NAME";
static const string UnitNameColorDataTableIdentifier = ".NAMECOLOR";

static const int UnitCacheMaAxString = 500;
static const int UnitCacheOverwriteCheckLimit = 10;
static const int UnitCacheLimit = -1;

// Unit custom value indexes:
const int gv_LibapxUnitIndexId = 0;				// index for ID
const int gv_LibapxUnitIndexCacheCount = 1;		// index for current cache number (num caches)
const int gv_LibapxUnitIndexFlagAttach = 2;		// flag for @attach has been used
const int gv_LibapxUnitIndexFlagTint = 3;			// flag for @tint has been used
const int gv_LibapxUnitIndexFlagScale = 4;		// flag for @scale has been used
const int gv_LibapxUnitIndexFlagModelswap = 5;			// flag for @modelswap has been used
const int gv_LibapxUnitIndexFlagAnimspeed = 6;	// flag for @animspeed has been used
const int gv_LibapxUnitIndexFlagPlay = 7;			// flag for @play has been used
const int gv_LibapxUnitIndexFlagStatbars = 8;		// flag for @statbars has been used
const int gv_LibapxUnitIndexFlagRotate = 9;		// flag for @rotate has been used
const int gv_LibapxUnitIndexFlagDecal = 10;		// flag for @decal has been used 
const int gv_LibapxUnitIndexFlagLoaner = 11;		// flag for @loan has been used 

const int gv_LibapxUnitIndexWaygate = 15;			// region ID for waygates
const int gv_LibapxUnitIndexWaygateDialog = 16;	// attached waygate dialog ID
const int gv_LibapxUnitIndexWaygateAnchor = 17;	// flag for unit is waygate anchor

const int gv_LibapxUnitIndexTextTag = 20;		// flag for text tag set

const int gv_LibapxUnitIndexSplatOwner = 25;	   // Player number of spawn splat owner

const int gv_LibapxUnitTypeIndexId = 26;				// index for Unit Type ID for >set


// Each unit given a unique id. Each time unit created, counter increments
int gv_LibapxUnitIdCounter = 1;



// increment rate used for adjusting the spawn splat unit's scale and height
// when using mouse-click spawning
static const fixed gv_LibapxSplatIncrementRate = 0.01;



//includes
include "apex/engine/unit/unit.actor_cache.galaxy"


// LibapxMapUnitInit
// ====================
// - assigns unit IDs to any units preplaced on the map
void LibapxPreplacedUnitInitialize() {
	unitgroup g = UnitGroup(null, c_playerAny, RegionEntireMap(), UnitFilter(0, 0, (1 << c_targetFilterMissile), (1 << (c_targetFilterDead - 32)) | (1 << (c_targetFilterHidden - 32))), 0);

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		LibapxUnitSetId(UnitGroupLoopCurrent());
		UnitSetCustomValue(UnitGroupLoopCurrent(), gv_LibapxUnitIndexCacheCount, 1); //set the unit cache value
		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();

	return;
}

// LibapxUnitSetId
// =====================
// sets the unit's id via the custom value stored for unit
void LibapxUnitSetId(unit u) {
	UnitSetCustomValue( u, gv_LibapxUnitIndexId, IntToFixed(gv_LibapxUnitIdCounter));
	gv_LibapxUnitIdCounter += 1;
}

// LibapxUnitGetVal
// ===========================
// Gets a custom value stored to the unit.
string LibapxUnitGetVal(unit u, string valuename) {
	string unitId;
	string key;
	unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	key = unitId + "_" + valuename;
	return DataTableGetString(true, key);

}

// LibapxUnitGetValEvent
// ===========================
// Gets a custom value stored to the unit from >event. Used for unit_events.galaxy
string LibapxUnitGetValEvent(unit u, string valuename) {
	string unitId;
	string event;
	unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	event = unitId + "_" + valuename;
	return DataTableGetString(true, event);

}

const string gv_LibapxAllKeys = "key_0 key_1 key_2 key_3 key_4 key_5 key_6 key_7 key_8 key_9 key_a key_b key_c key_d key_e key_f key_g key_h key_i key_j key_k key_l key_m key_n key_o key_p key_q key_r key_s key_t key_u key_v key_w key_x key_y key_z key_up key_down key_left key_right key_pgup key_pgdown key_numpad0 key_numpad1 key_numpad2 key_numpad3 key_numpad4 key_numpad5 key_numpad6 key_numpad7 key_numpad8 key_numpad9 key_numpadplus key_numpadminus key_numpadmultiply key_numpaddivide key_numpaddecimal key_grave";
const string gv_LibapxAllEvents = "attack attacked attackmove attackmoveFinish attackmoveCancel highlightOn highlightOff hold holdFinish holdCancel scanmove scanmoveComplete scanmoveCancel turn turnFinish turnCancel death move moveCancel moveFinish patrol patrolAllStages patrolCancel click select unselect acquire idle stop life shields energy kill exp height level movement";

// LibapxUnitSetVal
// ===========================
// Gets a custom value stored to the unit.
void LibapxUnitSetVal(unit u, string valuename, string value) {
	string unitId;
	string key;
	int i;
	string comparison;
	unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	i = 1;
	while(StringWord(gv_LibapxAllKeys, i) != "") {
		comparison = StringWord(gv_LibapxAllKeys, i);
		if(comparison == valuename) {
			key =  unitId + "_" + comparison;
		}
		i+=1;
	}
	DataTableSetString(true, key, value);
	return;
}

// LibapxUnitSetValEvent
// ===========================
// Gets a custom value stored to the unit. For >event
void LibapxUnitSetValEvent(unit u, string valuename, string value) {
	string unitId;
	string event;
	int i;
	string comparison;
	unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	i = 1;
	while(StringWord(gv_LibapxAllEvents, i) != "") {
		comparison = StringWord(gv_LibapxAllEvents, i);
		if(comparison == valuename) {
			event =  unitId + "_" + comparison;
		}
		i+=1;
	}
	DataTableSetString(true, event, value);
	return;
}


// LibapxUnitId
// =====================
// returns the unit's id as a string
string LibapxUnitId(unit u) {
	return FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
}



// LibapxUnitInitialize
// ===================
// runs when unit created (from UnitCreate or from unit abils)
// sets the unit's id and sets command cache count to 1
bool LibapxUnitInitialize(bool testConds, bool runActions) {
	// if unit already has data initialized -> skip
	if( UnitGetCustomValue( EventUnitCreatedUnit(), gv_LibapxUnitIndexId ) > 0 ) {
		return true;
	}

	LibapxUnitSetId(EventUnitCreatedUnit());
	UnitSetCustomValue(EventUnitCreatedUnit(), gv_LibapxUnitIndexCacheCount, 1);
	return true;

}

// LibapxUnitCreate
// =====================
// function for creating units:
// - Creates unit and initializes its ID.
//    -> If player using mouse-click spawning, copies the commands on the
//       spawn splat to the unit being created.
unitgroup LibapxUnitCreate(string type, int player, point p, fixed facing, int spawningCount) {
	unitgroup spawned;
	unit u;
	string splatUnitId;
	string cache;
	int index = 1;
	string key;
	spawned = UnitCreate(1, type, c_unitCreateIgnorePlacement, player, p, facing);
	u = UnitLastCreated(); // store the unit, since spawned is a unit group
	UnitSetFacing( u, facing, 0.0 ); // since structures cant spawn with non default facing
	UnitSetState( u, c_unitStateFidget, false);

	// initialize the spawned unit ID and initial cache # to 1
	// -> required because there is a delay until the other initializer event
	//    trigger LibapxUnitInitialize runs which causes issues with functions
	//    executed immediately after spawning
	LibapxUnitSetId(u);

	if(StringFind(type, "colossus", c_stringNoCase) != -1 ) {
		key = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + ".COLOSSUS";
		DataTableSetString(true, key, "HASCOLOSSUS"); //Sets the flag
	}


	UnitSetCustomValue(u, gv_LibapxUnitIndexCacheCount, 1);
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagLoaner, IntToFixed(player));

	if( gv_LibapxPlayer[player].isPlacingUnit ) {
		UnitSetHeight(u, UnitGetHeight(gv_LibapxPlayer[player].spawnSplat), 0);

		// apply spawn splat cache onto spawned unit
		splatUnitId = FixedToString( UnitGetCustomValue( gv_LibapxPlayer[player].spawnSplat, gv_LibapxUnitIndexId), 0 );
		while( DataTableValueExists(true, splatUnitId + "." + IntToString(index)) ) {
			cache = DataTableGetString(true, splatUnitId + "." + IntToString(index));
			LibapxChatParse( cache, player, spawned, spawningCount );
			index += 1;
		}



		// set player owner to the splat's player owner
		UnitSetOwner(u, UnitGetOwner(gv_LibapxPlayer[player].spawnSplat), true);
	}



	return spawned;
}

// LibapxSpawnCreateSplat
// =====================
// creates the unit splat under the cursor when using mouse-click spawn
// because we cannot get the actor type from a unit,
// we use a unit as the splat
void LibapxSpawnCreateSplat(string type, int player, int spawningCount) {
	unitgroup splat = UnitGroupEmpty();

	// remove any existing spawn splat
	if(gv_LibapxPlayer[player].spawnSplat != null) {
		// reset the custom value for owner to not trigger the data remove
		// function to reset player mouse movement
		UnitSetCustomValue(gv_LibapxPlayer[player].spawnSplat, gv_LibapxUnitIndexSplatOwner, 0);
		UnitRemove(gv_LibapxPlayer[player].spawnSplat);
	}

	// create splat and set player splat state variables
	UnitCreate(1, type, 0, player, gv_LibapxPlayer[player].mousePosition, 270.0);
	gv_LibapxPlayer[player].spawnSplat = UnitLastCreated();
	gv_LibapxPlayer[player].spawnSplatX = 1;
	gv_LibapxPlayer[player].spawnSplatY = 1;
	gv_LibapxPlayer[player].spawnSplatZ = 1;

	// initialize splat unit id/cache
	// (unit init event does not occurr till function already finished)
	LibapxUnitSetId(gv_LibapxPlayer[player].spawnSplat);
	UnitSetCustomValue(gv_LibapxPlayer[player].spawnSplat, gv_LibapxUnitIndexCacheCount, 1);

	// set the splat's owner player as a stored custom value
	UnitSetCustomValue(gv_LibapxPlayer[player].spawnSplat, gv_LibapxUnitIndexSplatOwner, IntToFixed(player));

	// set visuals
	UnitSetState(gv_LibapxPlayer[player].spawnSplat, c_unitStateInvulnerable, true);
	UnitSetState(gv_LibapxPlayer[player].spawnSplat, c_unitStatePaused, true);
	UnitSetState(gv_LibapxPlayer[player].spawnSplat, c_unitStateSelectable, false);
	UnitSetState(gv_LibapxPlayer[player].spawnSplat, c_unitStateTargetable, false);
	UnitSetState(gv_LibapxPlayer[player].spawnSplat, c_unitStateMoveSuppressed, true);
	UnitSetState(gv_LibapxPlayer[player].spawnSplat, c_unitStateRadarable, false);
	ActorSend(libNtve_gf_MainActorofUnit(gv_LibapxPlayer[player].spawnSplat), "SetOpacity .5");
	UnitBehaviorAdd(gv_LibapxPlayer[player].spawnSplat, LibapxBehaviorSUPPRESSCOLLISION, gv_LibapxPlayer[player].spawnSplat, 1);

	// set context to spawn splat, so commands applied to it
	UnitGroupAdd(splat, gv_LibapxPlayer[player].spawnSplat);
	gv_LibapxPlayerParser[player][spawningCount].context = splat;
}

// LibapxSpawnSplatUpdatePos
// ========================
// Updates the spawn splat's position and facing angle. Function is called by
// the mouse event in order to update splat as player moves mouse during
// mouse click spawning.
void LibapxSpawnSplatUpdatePos() {
	// if control held down, make spawn splat face cursor
	if( gv_LibapxPlayer[EventPlayer()].keyCtrl ) {
		libNtve_gf_MakeUnitFacePoint( gv_LibapxPlayer[EventPlayer()].spawnSplat, gv_LibapxPlayer[EventPlayer()].mousePosition, 0.0);
	}
	// else, update splat position if position not locked
	else if ( !gv_LibapxPlayer[EventPlayer()].keyShift && 	// shift key (scale) lock
			  !gv_LibapxPlayer[EventPlayer()].keyAlt && 		// alt key (height) lock
			  !gv_LibapxPlayer[EventPlayer()].mouseRight ) { // right mouse lock
		UnitSetPosition(gv_LibapxPlayer[EventPlayer()].spawnSplat, gv_LibapxPlayer[EventPlayer()].mousePosition, false);
	}
}

// LibapxSpawnSplatUpdateProps
// =====================
// Event trigger for updating the mouse-click spawn splat scale and height
// properties. This function responds to player mouse changes in the Y axis,
// which is used uniquely for scale and height changing.
//
// TODO: allow shift + x, shift + y, shift + z to scale axis components
void LibapxSpawnSplatUpdateProps(int player, bool scaleIncr)  {
	// if shift held down, scale model with Y mouse movement
	if( gv_LibapxPlayer[player].keyShift ) {
		if( scaleIncr ) { // increase size
			gv_LibapxPlayer[player].spawnSplatX += gv_LibapxSplatIncrementRate;
		} else { // decrease size
			gv_LibapxPlayer[player].spawnSplatX -= gv_LibapxSplatIncrementRate;
		}
		ActorSendTo(libNtve_gf_MainActorofUnit(gv_LibapxPlayer[player].spawnSplat), "::Main", "SetScale " + FixedToString(gv_LibapxPlayer[player].spawnSplatX, 2));
		LibapxUnitCacheUpdate(gv_LibapxPlayer[player].spawnSplat, "@scale", "@scale " + FixedToString(gv_LibapxPlayer[player].spawnSplatX, 2));
	}

	// if alt held down, change unit height with Y mouse movement
	if( gv_LibapxPlayer[player].keyAlt ) {
		if( scaleIncr ) { // move up
			UnitSetHeight(gv_LibapxPlayer[player].spawnSplat,
						  UnitGetHeight(gv_LibapxPlayer[player].spawnSplat) + gv_LibapxSplatIncrementRate, 0);
		} else { // move down
			UnitSetHeight(gv_LibapxPlayer[player].spawnSplat,
						  UnitGetHeight(gv_LibapxPlayer[player].spawnSplat) - gv_LibapxSplatIncrementRate, 0);
		}
	}


}

// LibapxUnitSetName
// ===================
// Sets a unit's custom name into the global data table with format
// [unitId]NAME : [name]
void LibapxUnitSetName(string name, unit u) {
	string key = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + UnitNameDataTableIdentifier;
	DataTableSetString(true, key, name);
}





//returns a boolean based on the unitgroup whether unit should be removed or not.
void LibapxUnitColossusRemove(unit u) {
	string colossus = DataTableGetString(true, FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + ".COLOSSUS");
	string colossusded = DataTableGetString(true, FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + ".COLOSSUSDED");

	if (colossus == "HASCOLOSSUS") {
		if (colossusded == "HASCOLOSSUSDED") {
			//kill
			UnitRemove(UnitGroupLoopCurrent());
			LibapxLogInfo(EventPlayer(), "Colossus with height and scale is a viable means to crash the game, removing unit.");
		}
	}
	return;
}

// LibapxUnitFlagColossus
// ===================
// Flags a unit that has colossus
void LibapxUnitFlagColossus(unit u) {
	string key = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + ".COLOSSUS";
	DataTableSetString(true, key, "HASCOLOSSUS"); //Sets the flag
	LibapxUnitColossusRemove(u);
}
//Predone string to determine if it's a threat
//ex
//@height 123;@modelswap colossus
//The height 123 would flag this before a colossus is even detected

void LibapxUnitFlagColCrashable(unit u) {
	string key = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + ".COLOSSUSDED";
	DataTableSetString(true, key, "HASCOLOSSUSDED"); //Sets the flag
	LibapxUnitColossusRemove(u);
}



// LibapxUnitSetNameColor
// ===================
// Sets a unit's name color into global data table
// [unitId]NAMECOLOR : [name]
void LibapxUnitSetNameColor(color col, unit u) {
	string key = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0) + UnitNameColorDataTableIdentifier;
	DataTableSetColor(true, key, col);
}

// LibapxUnitGetName
// ==================
// Gets a unit's custom name from the data table
// if no custom name, default to catalog name
text LibapxUnitGetName(unit u) {
	text name = StringToText("");
	string unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);

	// check if unit has custom name in data table
	if( DataTableValueExists(true, unitId + UnitNameDataTableIdentifier) ) {
		name = StringToText( DataTableGetString(true, unitId + UnitNameDataTableIdentifier) );
	}
	else if( (LibapxUnitnameGetEntry(u) != "") ) {
		name = StringToText(LibapxUnitnameGetEntry(u));
	}
	else { //get default catalog name
		name = StringExternal(  CatalogFieldValueGet(c_gameCatalogUnit, UnitGetType(u), "Name", UnitGetOwner(u)) );
	}


	// check if unit name has a custom color in data table
	// if( DataTableValueExists(true, unitId + UnitNameColorDataTableIdentifier) ) {
	// 	name = TextWithColor(name, DataTableGetColor(true, unitId + UnitNameColorDataTableIdentifier));
	// }
	// else { // tint to player's color
		// name = TextWithColor(name, ColorFromIndex((PlayerGetColorIndex(UnitGetOwner(u), false)), c_teamColorDiffuse));
	// }



	return name;
}



// LibapxUnitDataRemove
// ======================
// iterates through the unit's caches in data table and removes them
// -> if unit had a custom setname or setnamecolor, remove these as well
// -> destroy any text tags (labels) associated with unit
void LibapxUnitDataRemove(unit u) {
	string unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	int i = 1;
	int owner;


	// remove caches:
	while(DataTableValueExists(true, unitId + "." + IntToString(i))) {
		DataTableValueRemove(true, unitId + "." + IntToString(i));
		i += 1;
	}

	// check and remove setname/setnamecolor
	if( DataTableValueExists(true, unitId + UnitNameDataTableIdentifier) ) {
		DataTableValueRemove(true, unitId + UnitNameDataTableIdentifier);
	}
	if( DataTableValueExists(true, unitId + UnitNameColorDataTableIdentifier) ) {
		DataTableValueRemove(true, unitId + UnitNameColorDataTableIdentifier);
	}
	if( DataTableValueExists(true, unitId + UnitNameDataTableIdentifier) ) {
		DataTableValueRemove(true, unitId + UnitNameDataTableIdentifier);
	}

	// destroy any associated text tags
	if( UnitGetCustomValue(u, gv_LibapxUnitIndexTextTag) > 0.0 ) {
		TextTagDestroy( FixedToInt( UnitGetCustomValue(u, gv_LibapxUnitIndexTextTag) ) );
	}

	// check if unit killed/removed was the player spawn splat
	// if so, set player to no longer spawning
	owner = FixedToInt(UnitGetCustomValue(u, gv_LibapxUnitIndexSplatOwner));
	if( owner > 0 ) {
		gv_LibapxPlayer[owner].isPlacingUnit = false;
		UISetSelectionTypeEnabled(PlayerGroupSingle(owner), c_localSelectionTypeUnknown, true);
	}

}

// UNIT COMMAND CACHE SYSTEM:
// Caches are the command history of a unit stored in the data table
// specific commands that affect unit visuals, naming, behaviors, weapons
//
// Data table architecture (cache numbers start at index 1):
// [Key: UNITID.CACHENUMBER] : [Value: Cached command string]
//
// To conserve space, certain commands will be overwritten for each actor
// attached to a unit (e.g. @tint or @scale will overwrite the previous one)
// When a new actor is attached, this overwrite works to the last instance of attach.
// When commands are to be overwritten, a unit custom value flag is set (see consts).

// LibapxUnitCacheUpdateAdd
// =====================
// directly appends a new command to a unit's data table command cache,
// if there is still room in its current cache.
// else, create add a new cache string and increment cache counter
void LibapxUnitCacheUpdateAdd(unit subject, string unitId, string userCommand) {
	string cache;

	if(userCommand == "") {
		return;
	}

	if(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount) == 0) {
		UnitSetCustomValue(subject, gv_LibapxUnitIndexCacheCount, 1);
	}

	if(DataTableValueExists(true, unitId + "." + FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount), 0))) {
		cache = DataTableGetString(true, unitId + "." + FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount), 0));
	}
	else {
		cache = "";
	}

	if(cache == "") {
		cache = userCommand;
		DataTableSetString(true, unitId + "." + FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount), 0), cache);
		return;
	}
	else if(StringLength(cache + "; " + userCommand) <= UnitCacheMaAxString) {
		
		cache = cache + "; " + userCommand;
		DataTableSetString(true, unitId + "." + FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount), 0), cache);
		return;
	}
	else {
		UnitSetCustomValue(subject, gv_LibapxUnitIndexCacheCount, UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount) + 1);
		DataTableSetString(true, unitId + "." + FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount), 0), userCommand);
		return;
	}

}


// LibapxUnitCacheUpdateOverwrite
// =======================
// finds previous instance of command and removes it, then adds
// new command (if there is space; see LibapxUnitCacheUpdateAdd)
void LibapxUnitCacheUpdateOverwrite(unit subject, string unitId, string command, string userCommand) {
	bool cmdFound = false;
	int unitCaches = FixedToInt(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount));
	string cache;
	string cacheNext;
	string cmdNext;
	int x;
	int posStart;
	int posEnd;
	int i = 0;
	int j;

	//narrow to a certain cache number
	//overwrite check added because if check limit is too large, A LOT OF LAG
	i = 0;
	while(i < unitCaches && i < UnitCacheOverwriteCheckLimit) {
		if(StringContains(DataTableGetString(true, unitId + "." + IntToString(unitCaches - i)), command, c_stringAnywhere, c_stringNoCase)) {
			break;
		}
		i += 1;
	}
	if(i == UnitCacheOverwriteCheckLimit || i == unitCaches) { //past overwrite limit or doesnt exist: simply add the command
		LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
		return;
	}

	//search through cache(s) to find previous command
	while(!cmdFound && i < unitCaches) {
		cache = DataTableGetString(true, unitId + "." + IntToString(unitCaches - i));
		posStart = StringLength(cache);

		// get number of words separated by spaces in the string
		x = 1;
		while(StringWord(cache, x + 1) != "") {
			x += 1;
		}

		while(x > 0) {
			if(StringContains(StringWord(cache, x), command, c_stringAnywhere, c_stringNoCase)) { //found match
				cmdFound = true;

				if(x != 1) { //if not first command, set position to ';'
					posStart = posStart - StringLength(StringWord(cache, x)); //sets position to '@'
					while(StringSub(cache, posStart, posStart) != ";") { //not first cmd: finds the ';'
						posStart -= 1;
					}
				}
				else { //this is the first command
					posStart = 1;
				}
				break;
			}
			posStart = posStart - StringLength(StringWord(cache, x));
			while(StringSub(cache, posStart, posStart) == " ") {
				posStart -= 1;
			}
			x -= 1;
		}
		if(cmdFound) {
			break;
		}
		i += 1;
	}

	// find the end pos of the command; search till find the '@' of the next command
	// assumption is that only unit commands prefixed with '@' will be cached
	posEnd = posStart;
	if(posStart == 1) {
		while(posEnd < StringLength(cache)) {
			if(StringSub(cache, posEnd + 1, posEnd + 1) == "@") {
				break;
			}
			posEnd += 1;
		}
	}
	else {
		while(posEnd < StringLength(cache)) {
			if(StringSub(cache, posEnd + 1, posEnd + 1) == ";") {
				break;
			}
			posEnd += 1;
		}
	}

	//remove the previous command
	cache = StringReplace(cache, "", posStart, posEnd);

	if(i == 0) { //latest cache: only need to update this one
		if(cache == "") { //if cache empty, delete
			DataTableValueRemove(true, unitId + "." + IntToString(unitCaches));
		}
		else { //otherwise update it!
			DataTableSetString(true, unitId + "." + IntToString(unitCaches), cache);
		}
	}

	//otherwise update all proceeding caches to ensure they have max possible length < UnitCacheMaAxString
	while(i > 0) {
		cacheNext = DataTableGetString(true, unitId + "." + IntToString(unitCaches - i + 1));

		posStart = 1;
		posEnd = 1;
		while(posEnd < StringLength(cacheNext)) {
			if(StringSub(cacheNext, posEnd, posEnd + 1) == "; ") {
				posEnd += 1; //to include the space for removal
				break;
			}
			posEnd += 1;
		}

		cmdNext = StringSub(cacheNext, posStart, posEnd);
		if(StringLength(cache + "; " + cmdNext) <= UnitCacheMaAxString) { //remove comand from next cache, add to previous
			cache = cache + "; " + cmdNext;
			cacheNext = StringReplace(cacheNext, "", posStart, posEnd);

			DataTableSetString(true, unitId + "." + IntToString(unitCaches - i), cache);
			if(cacheNext == "") { //the latest cache is now empty; update unit
				DataTableValueRemove(true, unitId + "." + IntToString(unitCaches - i + 1));
				UnitSetCustomValue(subject, gv_LibapxUnitIndexCacheCount, IntToFixed(unitCaches - 1));
				unitCaches -= 1;
				break;
			}
			else {
				DataTableSetString(true, unitId + "." + IntToString(unitCaches - i + 1), cacheNext);
			}

			//now the check repeats
		}
		else {
			//go to the next cache
			i -= 1;
			cache = DataTableGetString(true, unitId + "." + IntToString(unitCaches - i));
		}
	}

	//now add the new command to the caches
	LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
}

void LibapxUnitCacheUpdate(unit subject, string command, string userCommand);

void LibapxUnitCacheReplaceeall(unit subject, string commands) {
	int unitCaches = FixedToInt(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount));
	int caches = unitCaches;
	string unitId = FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexId), 0);
	string command;
	string userinput;


	//Remove caches
	while(caches != 0) {
		LibapxLogInfo(EventPlayer(), unitId + "." + IntToString(caches) + " Unit ID  + Caches Wiped");
		DataTableSetString(true, unitId + "." + IntToString(caches), "");
		caches -= 1;
	}

	UnitSetCustomValue(subject, gv_LibapxUnitIndexCacheCount, 1);

	while( commands != "" ) {
		//get command
		if (StringFind(commands, ";", c_stringNoCase) != -1) {
			command = StringSub(commands, 1, StringFind(commands, ";", c_stringNoCase));
			command = StringReplace(command, "", StringFind(command, ";",c_stringNoCase), StringFind(command, ";",c_stringNoCase)+1 );
		}
		else {
			command = StringSub(commands, 1, StringLength(commands));
		}
		commands = StringReplace(commands, "", StringFind(commands, ";",c_stringNoCase), StringFind(command, ";",c_stringNoCase)+1 );
		commands = StringSub(commands, StringLength(command)+1, StringLength(commands));
		
		LibapxLogInfo(EventPlayer(), command);
		//check if command exceeds cache limit
		LibapxUnitCacheUpdate(subject, StringWord(command, 1), command);
		//Apply command

	}
	
}

string LibapxUnitsubtitleGetEntry(unit u);

//This formats subtitle when @subtitle -add is used to include the new text.
string LibapxUnitCacheReformatsubtitleAll(unit u, string argv) {
	string description;
    //REturn renameall
	description = CatalogFieldValueGet(c_gameCatalogUnit, UnitGetType(u), "Subtitle", UnitGetOwner(u));
	
	while(
		StringContains(description, "-add",c_stringAnywhere, false) ||
		StringContains(description, "+add",c_stringAnywhere, false) ||
		StringContains(description, "@subtitleall",c_stringAnywhere, false)
	)	{
		description = StringReplaceWord(description, "-add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "+add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "@subtitleall", "", 1, c_stringNoCase);
	}

    //Will sometimes return Unit/Name/{Units Name}
    //Thus we check if it does and then substring if needed.
    if(StringContains(description, "UnitSubtitle/", c_stringAnywhere, false)) {
        description = StringSub(description, 14, StringLength(description));
    }
	return "@subtitleall " + description;
}

//This formats subtitle when @subtitle -add is used to include the new text.
string LibapxUnitCacheReformatsubtitle(unit u, string argv) {
	string description;
	description = LibapxUnitsubtitleGetEntry(u);

	while(
		StringContains(description, "-add",c_stringAnywhere, false) ||
		StringContains(description, "+add",c_stringAnywhere, false) ||
		StringContains(description, "@subtitle",c_stringAnywhere, false)
	)	{
		description = StringReplaceWord(description, "-add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "+add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "@subtitle", "", 1, c_stringNoCase);
	}

	return "@subtitle " + description;
}
string LibapxUnitdescGetEntry(unit u);

//This formats desc when @desc -add is used to include the new text.
string LibapxUnitCacheReformatdesc(unit u, string argv) {
	string description;
	description = LibapxUnitdescGetEntry(u);

	while(
		StringContains(description, "-add",c_stringAnywhere, false) ||
		StringContains(description, "+add",c_stringAnywhere, false) ||
		StringContains(description, "@desc",c_stringAnywhere, false)
	)	{
		description = StringReplaceWord(description, "-add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "+add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "@desc", "", 1, c_stringNoCase);
	}

	return "@desc " + description;
}

string LibapxUnitdescallGetEntry(unit u);

//This formats descall when @descall -add is used to include the new text.
string LibapxUnitCacheReformatdescall(unit u, string argv) {
	string description;
	description = LibapxUnitdescallGetEntry(u);

	while(
		StringContains(description, "-add",c_stringAnywhere, false) ||
		StringContains(description, "+add",c_stringAnywhere, false) ||
		StringContains(description, "@descall",c_stringAnywhere, false)
	)	{
		description = StringReplaceWord(description, "-add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "+add", "", 1, c_stringNoCase);
		description = StringReplaceWord(description, "@descall", "", 1, c_stringNoCase);
	}
	return "@descall " + description;
}




// LibapxUnitCacheUpdate
// =====================
// redirects to proper cache update function depending on command:
// -> certain commands will overwrite previous (save space)
// -> other commands always added because dont know whether its safe
//    or not to rewrite previous instance
void LibapxUnitCacheUpdate(unit subject, string command, string userCommand) {
	string unitId = FixedToString(UnitGetCustomValue(subject, gv_LibapxUnitIndexId), 0);

	//if map has cache limit, checks for limit
	if( UnitCacheLimit != -1 && FixedToInt(UnitGetCustomValue(subject, gv_LibapxUnitIndexCacheCount)) > UnitCacheLimit ) {
		return;
	}


	if(command == "@attach") {
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagAttach, 1); // Flag true that @attach has been used
	}

	// VISUALS - attach, modelswap, tint, scale, animspeed, play
	// only overwrite for specific instances of an actor (after attach)
	if(command == "@attach" || command == "@rotation") {
		LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagTint, 0); //"reset" tint
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagScale, 0); //"reset" scale
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagModelswap, 0); //"reset" modelswap
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagAnimspeed, 0); //"reset" animspeed
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagPlay, 0); //"reset" play
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagStatbars, 0); //"reset" statbars
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagRotate, 0); //"reset" rotate
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagDecal, 0); //"reset" rotate
		return;
	}
	else if(command == "@attach-") {
		LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagTint, 0); //"reset" tint
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagScale, 0); //"reset" scale
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagModelswap, 0); //"reset" modelswap
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagAnimspeed, 0); //"reset" animspeed
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagPlay, 0); //"reset" play
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagStatbars, 0); //"reset" statbars
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagRotate, 0); //"reset" rotate
		UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagDecal, 0); //"reset" rotate
		return;
	}

	else if(command == "@tint") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagTint) != 1) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagTint, 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@scale") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagScale) != 1) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagScale, 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@modelswap") { // special case: allow for 2 instances, needed for modelers
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagModelswap) != 2) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagModelswap, UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagModelswap) + 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@animspeed") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagAnimspeed) != 1) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagAnimspeed, 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@play") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagPlay) != 1) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagPlay, 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@statbars") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagStatbars) != 1) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagStatbars, 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@rotate") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagRotate) != 1) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagRotate, 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	else if(command == "@decal") {
		if(UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagRotate) != 5) {
			LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
			UnitSetCustomValue(subject, gv_LibapxUnitIndexFlagRotate, UnitGetCustomValue(subject, gv_LibapxUnitIndexFlagRotate) + 1);
			return;
		}
		else {
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			return;
		}
	}
	// Never overwrite these commands: always add a new command to cache
	else if( command == "@actrmsg" ||
			 command == "@addbehavior" ||
			 command == "@removebehavior" ||
			 command == "@addweapon" ||
			 command == "@removeweapon" ||
			 command == "@effect" ||
			 command == "@state" ||
			 command == "@target"
			 ) {
		LibapxUnitCacheUpdateAdd(subject, unitId, userCommand);
		return;
	}
	// These commands always override previous when used, so always overwrite
	else if( command == "@adddamage" ||
			 command == "@addrange" ||
			 command == "@height" ||
			 command == "@invulnerable" ||
			 command == "@setname" ||
			 command == "@color" ||
			 command == "@tooltip" ||
			 command == "@weaponspeed" ||
			 command == "@weaponspeedall" ||
			 command == "@armor" ||
			 command == "@radius" ||
			 command == "@renameall" ||
			 command == "@rename" ||
			 command == "@subtitlebackgroundcolor" ||
			 command == "@subtitlebordercolor" ||
			 command == "@shieldsarmor" ) {
		LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
		return;
	}
	else if (
		command == "@subtitle" ||
		command == "@subtitleall"
	) {
		if (StringWord(userCommand, 2) == "+add" || StringWord(userCommand, 2) == "-add" ) {
			if(command == "@subtitle") {
				userCommand = LibapxUnitCacheReformatsubtitle(subject, userCommand);
				LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			}
			else {
				userCommand = LibapxUnitCacheReformatsubtitleAll(subject, userCommand);
				LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			}
			return;
		}
		else {
			//Won't really work, o well.
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
		}
		return;
	}
	else if (
		command == "@desc" ||
		command == "@descall"
	) {
		if (StringWord(userCommand, 2) == "+add" || StringWord(userCommand, 2) == "-add" ) {
			if(command == "@desc") {
				userCommand = LibapxUnitCacheReformatdesc(subject, userCommand);
				LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			}
			else {
				userCommand = LibapxUnitCacheReformatdescall(subject, userCommand);
				LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
			}
			return;
		}
		else {
			//Won't really work, o well.
			LibapxUnitCacheUpdateOverwrite(subject, unitId, command, userCommand);
		}
		return;
	}
}


//LibapxUnitCacheSet
//===========================================
// Sets cache to input string
// Removes all previous caches and sets cache to new cache
void LibapxUnitCacheSet(unit u, string cache) {
	string unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	int unitCaches = FixedToInt(UnitGetCustomValue(u, gv_LibapxUnitIndexCacheCount));
	int i = 1;
	int owner;

	if(!DataTableValueExists(true, unitId + "." + IntToString(unitCaches))) {
		UnitSetCustomValue(u, gv_LibapxUnitIndexCacheCount, 1);
		unitCaches = 1;
	}

	// remove caches:
	while(i < unitCaches) {
		DataTableValueRemove(true, unitId + "." + IntToString(i));
		i += 1;
	}

	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagTint, 0); //"reset" tint
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagScale, 0); //"reset" scale
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagModelswap, 0); //"reset" modelswap
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagAnimspeed, 0); //"reset" animspeed
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagPlay, 0); //"reset" play
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagStatbars, 0); //"reset" statbars
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagRotate, 0); //"reset" rotate
	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagDecal, 0); //"reset" rotate

	///Removed for now:tm:
	UnitSetCustomValue(u, gv_LibapxUnitIndexCacheCount, 1);
	DataTableSetString(true, unitId + "." + IntToString(1), cache);
}

//LibapxUnitCacheAdd
//===========================================
// Sets cache to input string
// Removes all previous caches and sets cache to new cache
void LibapxUnitCacheAdd(unit u, string cache) {
	string unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	int unitCaches = FixedToInt(UnitGetCustomValue(u, gv_LibapxUnitIndexCacheCount));
	int i = 1;
	int owner;
	string currentCache = DataTableGetString(true, unitId + "." + IntToString(unitCaches));



	LibapxUnitCacheUpdateAdd(u, unitId, cache);
}


//Assist with pop
int LibapxFindLastCommandIndex(string cache) {
	int index = 0;
	while( StringFind(cache, ";",c_stringNoCase) != -1) {
		index += StringFind(cache, ";",c_stringNoCase);
		cache = StringReplace(cache, "", 1, StringFind(cache, ";",c_stringNoCase));
	}

	if(index == 0) {
		index = 1;
	}

	return index;
};

//s marine;>repeat 19 [@tint 255;@attach marine;@cache 2]

// LibapxUnitCachePop
// =================================
// Pops off the last command on the unit, DOES NOT MODIFY FLAGS, just pops like a stack
// Updates cache with popped off command
string LibapxUnitCachePop(unit u, bool modifyCache) {
	string unitId = FixedToString(UnitGetCustomValue(u, gv_LibapxUnitIndexId), 0);
	int unitCaches = FixedToInt(UnitGetCustomValue(u, gv_LibapxUnitIndexCacheCount));
	int i = 1;
	string currentCache = DataTableGetString(true, unitId + "." + IntToString(unitCaches));

	int lastIndex = LibapxFindLastCommandIndex(currentCache);
	string output = StringSub(currentCache, lastIndex, StringLength(currentCache));

	if(unitCaches == 0) {
		return "";
	}

	//Trim ; at beginning
	if(StringSub(output, 1,1) == ";") {
		output = StringSub(output, 2, StringLength(output));
	}

	//Trim ; at end
	currentCache = LibapxStringTrim(StringSub(currentCache, 1, lastIndex));
	if(StringSub(currentCache, StringLength(currentCache),StringLength(currentCache)) == ";") {
		currentCache = StringSub(currentCache, 1, StringLength(currentCache)-1);
	}

	//Only one character remaining
	if(StringLength(currentCache) == 1) {
		currentCache = "";
	}
	
	currentCache = LibapxStringTrim(currentCache);

	if(modifyCache) {
		if(currentCache == "") {
			UnitSetCustomValue(u, gv_LibapxUnitIndexCacheCount, IntToFixed(unitCaches - 1));
			DataTableValueRemove(true, unitId + "." + IntToString(unitCaches));
		}
		else {
			DataTableSetString(true, unitId + "." + IntToString(unitCaches), currentCache);
		}
	} 

	return output;
}

int LibapxGetCommandActorCount(string argv) {
	string command = StringWord(argv, 1);
	int i = 2;
	string arg;
	int output = 0;
	bool modYpr;

	if(StringFind( argv, "-nocache",c_stringNoCase) != -1) {
		argv =  StringReplaceWord(argv, "-nocache", "", 1, c_stringNoCase);
	}
	//Remove, and check for, modifiers.
	if( StringFind(argv, "-ypr", c_stringNoCase) != -1 ) {
		modYpr = true;
		argv = StringReplaceWord(argv, "-ypr",  "", 1, c_stringNoCase);
	} 

	if( StringFind(argv, "-b", c_stringNoCase) != -1 ) {
		argv = StringReplaceWord(argv, "-b",  "", 1, c_stringNoCase);
	} 
	if( StringFind(argv, "-a", c_stringNoCase) != -1 ) {
		argv = StringReplaceWord(argv, StringWord(StringSub(argv, StringFind(argv, "-a", c_stringNoCase), StringLength(argv)), 2),  "", 1, c_stringNoCase);
		argv = StringReplaceWord(argv, "-a",  "", 1, c_stringNoCase);
	} 


	if(command == "@attach") {
		return 1;
	}
	if(command == "@rotation") {
		//This one is MORE complicated
		while(StringWord(argv, i) != "") {
			arg = StringWord(argv, i);
			i+=1;
			//Remove modifiers, they add NOTHING
			if(!modYpr) {
				if(StringFind(arg, "x", c_stringNoCase) != -1) {
					output += 2;
				}
				if(StringFind(arg, "y", c_stringNoCase) != -1) {
					output += 1;
				}
				if(StringFind(arg, "z", c_stringNoCase) != -1) {
					output += 1;
				}
			}
			else {
				if(StringFind(arg, "y", c_stringNoCase) != -1) {
					output += 1;
				}
				if(StringFind(arg, "p", c_stringNoCase) != -1) {
					output += 1;
				}
				if(StringFind(arg, "r", c_stringNoCase) != -1) {
					output += 2;
				}
			}


		}
	}

	return output;
}



// Wait did I make this?
// I think this was my prototype for >events
void LibapxUnitAttackCheck(){
	int i;
	unitgroup target;
	unitgroup g;
	unit u;
	int player;
	string input;
	player = EventPlayer();
	target = UnitGroupSelected(player);
	g = target;

	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		i = i + 1;
		u = UnitGroupLoopCurrent();


		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	if(i > 1) {
		return;
	}
	if(	player != UnitGetOwner(u) ) {
		return;
	}
	if(gv_LibapxPlayer[player].key_0 == true ) {
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);	
	}
	return;

	


}

void LibapxUnitKeypressCheck() {
	int i;
	unitgroup target;
	unitgroup g;
	unit u;
	int player;
	string input;
	player = EventPlayer();


	target = UnitGroupSelected(player);
	//target = LibapxEnforceUnitPermissions(target, player);


	g = target;



	UnitGroupLoopBegin(g);
	while(!UnitGroupLoopDone()) {
		i = i + 1;
		u = UnitGroupLoopCurrent();


		UnitGroupLoopStep();
	}
	UnitGroupLoopEnd();
	if(i > 1) {
		return;
	}
	if(	player != UnitGetOwner(u) ) {
		return;
	}
	if(gv_LibapxPlayer[player].key_0 == true ) {
		input = LibapxUnitGetVal(u, "key_0");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_1 == true ) {
		input = LibapxUnitGetVal(u, "key_1");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_2 == true ) {
		input = LibapxUnitGetVal(u, "key_2");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_3 == true ) {
		input = LibapxUnitGetVal(u, "key_3");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_4 == true ) {
		input = LibapxUnitGetVal(u, "key_4");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_5 == true ) {
		input = LibapxUnitGetVal(u, "key_5");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_6 == true ) {
		input = LibapxUnitGetVal(u, "key_6");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_7 == true ) {
		input = LibapxUnitGetVal(u, "key_7");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_8 == true ) {
		input = LibapxUnitGetVal(u, "key_8");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].key_9 == true ) {
		input = LibapxUnitGetVal(u, "key_9");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyA == true ) {
		input = LibapxUnitGetVal(u, "key_a");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyB == true ) {
		input = LibapxUnitGetVal(u, "key_b");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyC == true ) {
		input = LibapxUnitGetVal(u, "key_c");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyD == true ) {
		input = LibapxUnitGetVal(u, "key_d");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyE == true ) {
		input = LibapxUnitGetVal(u, "key_e");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyF == true ) {
		input = LibapxUnitGetVal(u, "key_f");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyG == true ) {
		input = LibapxUnitGetVal(u, "key_g");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyH == true ) {
		input = LibapxUnitGetVal(u, "key_h");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyI == true ) {
		input = LibapxUnitGetVal(u, "key_i");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyJ == true ) {
		input = LibapxUnitGetVal(u, "key_j");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyK == true ) {
		input = LibapxUnitGetVal(u, "key_k");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyL == true ) {
		input = LibapxUnitGetVal(u, "key_l");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyM == true ) {
		input = LibapxUnitGetVal(u, "key_m");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyN == true ) {
		input = LibapxUnitGetVal(u, "key_n");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyO == true ) {
		input = LibapxUnitGetVal(u, "key_o");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyP == true ) {
		input = LibapxUnitGetVal(u, "key_p");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyQ == true ) {
		input = LibapxUnitGetVal(u, "key_q");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyR == true ) {
		input = LibapxUnitGetVal(u, "key_r");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyS == true ) {
		input = LibapxUnitGetVal(u, "key_s");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyT == true ) {
		input = LibapxUnitGetVal(u, "key_t");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyU == true ) {
		input = LibapxUnitGetVal(u, "key_u");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyV == true ) {
		input = LibapxUnitGetVal(u, "key_v");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyW == true ) {
		input = LibapxUnitGetVal(u, "key_w");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyX == true ) {
		input = LibapxUnitGetVal(u, "key_x");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyY == true ) {
		input = LibapxUnitGetVal(u, "key_y");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyZ == true ) {
		input = LibapxUnitGetVal(u, "key_z");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyUp == true ) {
		input = LibapxUnitGetVal(u, "key_up");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyDown == true ) {
		input = LibapxUnitGetVal(u, "key_down");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyLeft == true ) {
		input = LibapxUnitGetVal(u, "key_left");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyRight == true ) {
		input = LibapxUnitGetVal(u, "key_right");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyPgUp == true ) {
		input = LibapxUnitGetVal(u, "key_pgup");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyPgDown == true ) {
		input = LibapxUnitGetVal(u, "key_pgdown");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad0 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad0");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad1 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad1");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad2 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad2");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad3 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad3");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad4 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad4");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad5 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad5");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad6 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad6");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad7 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad7");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad8 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad8");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPad9 == true ) {
		input = LibapxUnitGetVal(u, "key_numpad9");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPadPlus == true ) {
		input = LibapxUnitGetVal(u, "key_numpadplus");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPadMinus == true ) {
		input = LibapxUnitGetVal(u, "key_numpadminus");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPadMultiply == true ) {
		input = LibapxUnitGetVal(u, "key_numpadmultiply");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPadDivide == true ) {
		input = LibapxUnitGetVal(u, "key_numpaddivide");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyNumPadDecimal == true ) {
		input = LibapxUnitGetVal(u, "key_numpaddecimal");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	if(gv_LibapxPlayer[player].keyGrave == true ) {
		input = LibapxUnitGetVal(u, "key_grave");
		LibapxChatParse(input, player, g, gv_LibapxPlayer[player].spawningCount);
	}
	return;
}



// Loaner
// ===================================================
// Loaned units get around default apex permissioning
void LibapxUnitSetLoaner(unit u, int p) {

	UnitSetCustomValue(u, gv_LibapxUnitIndexFlagLoaner, IntToFixed(p));
}

void LibapxUnitRemoveLoaner(unit u) {
	 UnitSetCustomValue(u, gv_LibapxUnitIndexFlagLoaner, IntToFixed(-1));
}